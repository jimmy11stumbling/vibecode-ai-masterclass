import { supabase } from '@/integrations/supabase/client';
import { a2aProtocol } from './a2aProtocolCore';
import { createDeepSeekReasonerCore } from './deepSeekReasonerCore';
import { mcpHub } from './mcpHubCore';
import { ragDatabase } from './ragDatabaseCore';

export interface ProjectSpec {
  id: string;
  name: string;
  description: string;
  tech_stack: string[];
  architecture: string;
  user_stories: string[];
  execution_id: string;
}

export interface SovereignTask {
  id: string;
  type: string;
  description: string;
  status: 'pending' | 'in_progress' | 'completed' | 'failed';
  priority: 'high' | 'medium' | 'low';
  project_id: string;
  execution_id: string;
  assigned_agent?: string;
  dependencies: string[];
  result?: any;
}

export class SovereignOrchestrator {
  private deepSeekReasoner: any = null;
  private isInitialized = false;

  constructor() {
    console.log('üèõÔ∏è Sovereign Orchestrator initialized');
  }

  setApiKey(apiKey: string) {
    this.deepSeekReasoner = createDeepSeekReasonerCore(apiKey);
    console.log('üîë DeepSeek API key configured for Sovereign Orchestrator');
  }

  async processUserRequest(userQuery: string): Promise<string> {
    if (!this.deepSeekReasoner) {
      throw new Error('DeepSeek API key not configured. Please set the API key in settings.');
    }

    console.log(`üèõÔ∏è Orchestrator: Processing user request: ${userQuery}`);
    const executionId = `execution-${Date.now()}`;

    // 1. Project Definition
    const projectSpec = await this.defineProject(userQuery, executionId);
    console.log('üèõÔ∏è Orchestrator: Project defined:', projectSpec);

    // 2. Task Breakdown
    const tasks = await this.breakdownTasks(projectSpec, executionId);
    console.log('üèõÔ∏è Orchestrator: Tasks breakdown:', tasks);

    // 3. Agent Assignment
    const assignments = await this.assignTasksToAgents(tasks);
    console.log('üèõÔ∏è Orchestrator: Tasks assigned to agents:', assignments);

    // 4. Task Execution (Simulated)
    await this.executeTasks(assignments);

    return executionId;
  }

  private async defineProject(userQuery: string, executionId: string): Promise<ProjectSpec> {
    const reasoningContext = {
      projectId: executionId,
      userQuery: userQuery,
      systemInstructions: 'Define a project specification based on the user query. Include name, description, tech stack, architecture, and user stories.',
      previousContext: 'No previous project context.',
    };

    const reasoningResult = await this.deepSeekReasoner.performAdvancedReasoning(reasoningContext);

    try {
      const projectDetails = JSON.parse(reasoningResult.conclusion);

      const projectSpec: ProjectSpec = {
        id: `project-${Date.now()}`,
        name: projectDetails.name || 'Generated Project',
        description: projectDetails.description || 'A project generated by the Sovereign IDE',
        tech_stack: projectDetails.tech_stack || ['React', 'Node.js', 'PostgreSQL'],
        architecture: projectDetails.architecture || 'Microservices',
        user_stories: projectDetails.user_stories || ['User can log in', 'User can perform action'],
        execution_id: executionId
      };

      await supabase
        .from('projects')
        .insert(projectSpec);

      return projectSpec;
    } catch (error) {
      console.error('Error parsing project details:', error);
      
      const projectSpec: ProjectSpec = {
        id: `project-${Date.now()}`,
        name: 'Generated Project',
        description: 'A project generated by the Sovereign IDE',
        tech_stack: ['React', 'Node.js', 'PostgreSQL'],
        architecture: 'Microservices',
        user_stories: ['User can log in', 'User can perform action'],
        execution_id: executionId
      };

      await supabase
        .from('projects')
        .insert(projectSpec);

      return projectSpec
    }
  }

  private async breakdownTasks(projectSpec: ProjectSpec, executionId: string): Promise<SovereignTask[]> {
    const reasoningContext = {
      projectId: projectSpec.id,
      userQuery: `Break down the project ${projectSpec.name} into individual tasks.`,
      systemInstructions: 'Decompose the project into actionable tasks with clear descriptions, types, priorities, and dependencies.',
      previousContext: `Project Description: ${projectSpec.description}`,
    };

    const reasoningResult = await this.deepSeekReasoner.performAdvancedReasoning(reasoningContext);

    try {
      const taskDetails = JSON.parse(reasoningResult.conclusion);
      const tasks: SovereignTask[] = taskDetails.tasks.map((task: any) => ({
        id: `task-${Date.now()}`,
        type: task.type || 'development',
        description: task.description || 'Implement feature',
        status: 'pending',
        priority: task.priority || 'medium',
        project_id: projectSpec.id,
        execution_id: executionId,
        dependencies: task.dependencies || [],
      }));

      await supabase
        .from('tasks')
        .insert(tasks);

      return tasks;
    } catch (error) {
      console.error('Error parsing task details:', error);

      const tasks: SovereignTask[] = [
        {
          id: `task-${Date.now()}`,
          type: 'development',
          description: 'Implement initial feature',
          status: 'pending',
          priority: 'medium',
          project_id: projectSpec.id,
          execution_id: executionId,
          dependencies: [],
        }
      ];

      await supabase
        .from('tasks')
        .insert(tasks);

      return tasks;
    }
  }

  private async assignTasksToAgents(tasks: SovereignTask[]): Promise<{ task: SovereignTask; agentId: string }[]> {
    const assignments: { task: SovereignTask; agentId: string }[] = [];

    for (const task of tasks) {
      const availableAgents = a2aProtocol.getAllAgents();
      if (availableAgents.length > 0) {
        const agent = availableAgents[Math.floor(Math.random() * availableAgents.length)];
        task.assigned_agent = agent.id;
        assignments.push({ task, agentId: agent.id });

        await supabase
          .from('tasks')
          .update({ assigned_agent: agent.id })
          .eq('id', task.id);
      }
    }

    return assignments;
  }

  private async executeTasks(assignments: { task: SovereignTask; agentId: string }[]): Promise<void> {
    for (const assignment of assignments) {
      console.log(`Executing task ${assignment.task.id} with agent ${assignment.agentId}`);
      
      // Simulate task execution
      assignment.task.status = 'in_progress';
      await supabase
        .from('tasks')
        .update({ status: 'in_progress' })
        .eq('id', assignment.task.id);

      // Simulate task completion after a delay
      setTimeout(async () => {
        assignment.task.status = 'completed';
        await supabase
          .from('tasks')
          .update({ status: 'completed' })
          .eq('id', assignment.task.id);
        console.log(`Task ${assignment.task.id} completed`);
      }, 5000);
    }
  }

  async getTasks(executionId?: string): Promise<SovereignTask[]> {
    let query = supabase
      .from('tasks')
      .select('*');

    if (executionId) {
      query = query.eq('execution_id', executionId);
    }

    const { data, error } = await query;

    if (error) {
      console.error('Error fetching tasks:', error);
      return [];
    }

    return data || [];
  }

  async getActiveProjects(): Promise<ProjectSpec[]> {
     const { data, error } = await supabase
      .from('projects')
      .select('*');

    if (error) {
      console.error('Error fetching projects:', error);
      return [];
    }

    return data || [];
  }
}

export const sovereignOrchestrator = new SovereignOrchestrator();
